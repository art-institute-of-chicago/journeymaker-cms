<?php
/**
 * @file
 * Drupal Module: Image(Cache) Defaults
 *
 * Detects broken image links generated by Image and provides options to
 * remove them from display or replace them with a customizable default image.
 *
 * @author: David Meister <http://drupal.org/user/657782>
 */

/**
 * Define constants.
 */
define('IMAGECACHE_DEFAULTS_ADMIN_PATH', 'admin/config/media/image-styles/defaults');
define('IMAGECACHE_DEFAULTS_CACHE_BIN', 'cache_imagecache_defaults');

/**
 * Codes to indicate how Image(Cache) Defaults should handle broken images.
 */
define('IMAGECACHE_DEFAULTS_DISABLED', 'disabled');
define('IMAGECACHE_DEFAULTS_REMOVE_ALL', 'remove_all');
define('IMAGECACHE_DEFAULTS_REPLACE_VALID', 'replace_valid');
define('IMAGECACHE_DEFAULTS_REPLACE_ALL', 'replace_all');

/**
 * Drupal hooks.
 */

/**
 * Implements hook_menu().
 */
function imagecache_defaults_menu() {
  $items = array();
  $items[IMAGECACHE_DEFAULTS_ADMIN_PATH] = array(
    'title' => 'Defaults',
    'file' => 'imagecache_defaults.pages.inc',
    'description' => 'Administer image defaults.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('imagecache_defaults_settings'),
    'access arguments' => array('administer image styles'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  return $items;
}

/**
 * Implements hook_flush_caches().
 */
function imagecache_defaults_flush_caches() {
  return array(IMAGECACHE_DEFAULTS_CACHE_BIN);
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Provides wrappers around all image theme functions that generate image html
 * elements.
 *
 * We store the name of the functions we're overriding for our own functions to
 * use to avoid conflicts if another module is messing with $theme_registry.
 */
function imagecache_defaults_theme_registry_alter(&$theme_registry) {
  // Build an array of registry items to re-route.
  $theme_registry_items = array('image_style', 'image_formatter');

  foreach ($theme_registry_items as $theme_hook) {
    $theme_registry[$theme_hook]['imagecache_defaults_original_function'] = $theme_registry[$theme_hook]['function'];
    $theme_registry[$theme_hook]['function'] = 'theme_imagecache_defaults';
  }
}

/**
 * Get the original theme function that was overridden from $theme_registry.
 *
 * @return string
 *   The name of the original function.
 */
function _imagecache_defaults_get_theme_function($params) {
  $theme_registry = theme_get_registry();
  return $theme_registry[$params['theme_hook']]['imagecache_defaults_original_function'];
}

/**
 * Implements hook_image_default_styles().
 */
function imagecache_defaults_image_default_styles() {
  $styles = array();
  // We use this style to do some optional extra pre-processing of any
  // discovered default image before we use it.
  $styles['imagecache_defaults_prepare_default_image'] = array(
    'effects' => array(),
  );
  return $styles;
}

/**
 * Non-recursively scan a given directory for potential default images.
 *
 * @param string $dir
 *   A directory to scan.
 *
 * @return array
 *   An array of image files keyed by filename as returned by
 *   file_scan_directory().
 */
function _imagecache_defaults_image_search_scan_directory($dir) {
  $mask = '/.*imagecache_defaults.*/';
  $options = array(
    'recurse' => FALSE,
  );

  // Non-recursively scan for potential images.
  $scan = file_scan_directory($dir, $mask, $options);

  // Filter out any files that we can't validate as images.
  foreach ($scan as $uri => $file_info) {
    if (!imagecache_defaults_valid_image($uri)) {
      unset($scan[$uri]);
    }
  }
  return $scan;
}

/**
 * Scan for a default image and optionally cache it.
 *
 * Searches for an image file containing "imagecache_defaults" in the file name
 * in the following folders (in order):
 * - sites/<domain>/files
 * - sites/all/files
 * - profiles/<profile>/files
 * - path/to/imagecache_defaults/images
 * Stops searching as soon as a valid image is found and caches the result
 * using the standard Image method.
 *
 * @param array $params
 *   An optional array of options. Allowable keys are:
 *   - 'cache' = Boolean. If TRUE an Image derivative will be generated if
 *     required.
 *
 * @return string|false
 *   The uri of the derivative image if cache is TRUE, or the the discovered
 *   image if $cache is FALSE. Returns FALSE if no image could be found.
 */
function _imagecache_defaults_get_default_image_uri($params = array()) {
  // Merge in default params.
  $params += array(
    'cache' => TRUE,
  );
  $directory = 'files';
  $searchdir = array();

  // Default files directory.
  $searchdir[] = file_default_scheme() . '://';

  // sites/all
  $searchdir[] = 'sites/all/' . $directory;

  // profiles/<profile>
  $profile = drupal_get_profile();
  $searchdir[] = "profiles/$profile/$directory";

  // path/to/imagecache_defaults/images
  $module_path = drupal_get_path('module', 'imagecache_defaults');
  $searchdir[] = "$module_path/images";

  // Search each directory until we have at least one match then break.
  foreach ($searchdir as $dir) {
    $scan = _imagecache_defaults_image_search_scan_directory($dir);
    if (!empty($scan)) {
      break;
    }
  }

  // Get the first match.
  $uri = (!empty($scan)) ? reset($scan)->uri : FALSE;

  // Attempt to generate a copy of the discovered image somewhere that is more
  // Image-friendly; Image cannot process files outside public:// or private://
  if ($params['cache'] && $uri) {
    $style = variable_get('imagecache_defaults_default_image_style', 'imagecache_defaults_prepare_default_image');
    $style = image_style_load($style);
    $destination = image_style_path($style['name'], $uri);
    $destination = file_default_scheme() . '://' . file_uri_target($destination);

    // image_style_create_derivative() will return FALSE if a file already
    // exists at $destination but this causes problems for our cache setup.
    if (image_style_create_derivative($style, $uri, $destination) || file_exists($destination)) {
      $uri = $destination;
    }
  }

  return $uri;
}

/**
 * Get the variables required by the Image module to process the default image.
 *
 * The results of this function are statically cached for each page load.
 *
 * @return array
 *   An array of variables that can be used by theme_image_style() or
 *   theme_image_formatter().
 */
function _imagecache_defaults_get_default_variables() {
  $default_variables = array();
  $default_variables['path'] = $default_variables['uri'] = imagecache_defaults_get_default_image_uri();
  $image_info = image_get_info($default_variables['path']);
  $default_variables['height'] = $image_info['height'];
  $default_variables['width'] = $image_info['width'];

  return $default_variables;
}

/**
 * Internal function to decide whether we believe a given uri is an image file.
 *
 * @param array $params
 *   An array of parameters. Allowable keys are:
 *   - 'uri' = String. The uri to check.
 *
 * @return boolean
 *   TRUE if the uri is a valid image. FALSE otherwise.
 */
function _imagecache_defaults_valid_image($params = array()) {
  return (file_exists($params['uri']) && @getimagesize($params['uri'])) ? TRUE : FALSE;
}

/**
 * Decide if we believe that a given uri was potentially once a valid image.
 *
 * The uri is considered invalid if it:
 * - is numeric as defined by PHP
 * - is empty as defined by PHP
 * - is not a string
 * - is a directory
 * - contains a line break or carriage return character
 * - consists of only whitespace, '%', or ':' characters
 * - ends with a '/'
 *
 * The return value of this function is statically cached per uri. We are NOT
 * using drupal_static() because the validity of a uri will never change so
 * there is no need to reset this.
 *
 * @param string $uri
 *   The uri to validate
 *
 * @return boolean
 *   TRUE if the uri is not invalid, FALSE otherwise.
 */
function imagecache_defaults_valid_image_uri($uri) {
  // Check for things that would break our static array if used as keys.
  if (empty($uri) || !is_string($uri)) {
    return FALSE;
  }
  static $imagecache_defaults_valid_image_uri = array();
  if (!isset($imagecache_defaults_valid_image_uri[$uri])) {
    $pattern = '/(^[\s:%]+$)|([\n\r]+)|(\/$)/';
    $imagecache_defaults_valid_image_uri[$uri] = (is_numeric($uri) || is_dir($uri) || preg_match($pattern, $uri)) ? FALSE : TRUE;

    // Defer to Drupal if Drupal thinks this is a valid uri.
    if (file_valid_uri($uri)) {
      $imagecache_defaults_valid_image_uri[$uri] = TRUE;
    }
  }
  return $imagecache_defaults_valid_image_uri[$uri];
}

/**
 * Log a watchdog message when a uri replacement is attempted.
 *
 * @param string $uri
 *   The replaced uri.
 * @param boolean $success
 *   TRUE if the path was successfully replaced, FALSE if there was an error.
 */
function imagecache_defaults_log_replaced_uri($uri, $success) {
  // Check if watchdog messages are allowed.
  global $base_root;
  $watchdog = variable_get('imagecache_defaults_watchdog_enabled', FALSE);
  if (!$watchdog) {
    return;
  }
  $url = $base_root . request_uri();

  if ($success) {
    watchdog('imagecache_defaults', '%uri is a broken image visible at %url. It was replaced with the default image.', array('%uri' => $uri, '%url' => $url));
  }
  else {
    watchdog('imagecache_defaults', '%uri is a broken image visible at %url. The default image replacement failed. Please check that there is a valid default image available.', array('%uri' => $uri, '%url' => $url), WATCHDOG_ERROR);
  }
}

/**
 * Determine what operation needs to be performed on a given uri.
 *
 * @param string $uri
 *   A uri to lookup the operation for.
 *
 * @return string
 *   Possible values are 'ignore', 'replace' or 'remove'.
 */
function imagecache_defaults_get_op($uri) {
  $behaviour = variable_get('imagecache_defaults_broken_path_handling', IMAGECACHE_DEFAULTS_REPLACE_VALID);
  $op = 'ignore';
  // Do the relevant tests.
  $valid_uri = imagecache_defaults_valid_image_uri($uri);
  $valid_image = ($valid_uri) ? imagecache_defaults_valid_image($uri) : FALSE;

  // Ignore all valid images.
  if (!$valid_image) {
    if ($behaviour == IMAGECACHE_DEFAULTS_REMOVE_ALL || (!$valid_uri && $behaviour == IMAGECACHE_DEFAULTS_REPLACE_VALID)) {
      $op = 'remove';
    }
    if ($behaviour == IMAGECACHE_DEFAULTS_REPLACE_ALL || ($valid_uri && $behaviour == IMAGECACHE_DEFAULTS_REPLACE_VALID)) {
      $op = 'replace';
    }
  }
  return $op;
}

/**
 * Substitute out values used by the Image module with default values.
 *
 * Substitution is done in-place, ie. $variables is passed by reference. The
 * entire $variables array used by theme_image_style() should be passed directly
 * but only $variables['item'] in theme_image_formatter should be passed. The
 * result of this operation is logged by watchdog if required.
 *
 * @param array $variables
 *   The $variables array passed to them_image_style() or the $variables['item']
 *   passed to theme_image_formatter().
 *
 * @return boolean
 *   TRUE if $variables was updated correctly, FALSE if there was an error.
 */
function imagecache_defaults_replace_image_variables(&$variables) {
  $default_variables = imagecache_defaults_get_default_variables();

  // Images have a "path" in theme_image_style() but a "uri" in
  // theme_image_formatter().
  $uri_key = 'uri';
  $uri_key = (isset($variables[$uri_key])) ? $uri_key : 'path';
  $original_uri = $variables[$uri_key];

  // If the default image can't be found we've failed.
  if (empty($default_variables[$uri_key])) {
    $success = FALSE;
    imagecache_defaults_log_replaced_uri($original_uri, $success);
    return $success;
  }

  $variables[$uri_key] = $default_variables[$uri_key];
  $variables['width'] = $default_variables['width'];
  $variables['height'] = $default_variables['height'];

  $success = imagecache_defaults_valid_image($variables[$uri_key]);
  imagecache_defaults_log_replaced_uri($original_uri, $success);
  return $success;
}

/**
 * Cache implementation.
 */

/**
 * Wrapper around cache_get() and cache_set().
 *
 * This mainly exists to help implement and test the cache bypass functionality.
 * Historically this function also backported D7 static caching for cache_get()
 * to D6.
 */
function imagecache_defaults_cache($cid, $build_func, $params = array(), $reset = FALSE) {
  static $cache = array();

  if (empty($cid)) {
    return FALSE;
  }
  if (variable_get('imagecache_defaults_bypass_cache', FALSE)) {
    return $build_func($params);
  }

  // Hopefully we can use something in the static cache.
  if (!isset($cache[$cid]) || $reset) {
    if ($cache_get = cache_get($cid, IMAGECACHE_DEFAULTS_CACHE_BIN)) {
      // Fallback to the persistent cache.
      $cache[$cid] = $cache_get->data;
    }
    else {
      // Sigh.
      // We have to actually do some work :(
      $cache[$cid] = $build_func($params);
      cache_set($cid, $cache[$cid], IMAGECACHE_DEFAULTS_CACHE_BIN);
    }
  }
  return $cache[$cid];
}

/**
 * Cache wrapper around _imagecache_defaults_get_default_variables().
 *
 * The default image's dimensions and mimetype will almost never change.
 */
function imagecache_defaults_get_default_variables() {
  $cid = __FUNCTION__;
  $build_func = '_' . __FUNCTION__;
  return imagecache_defaults_cache($cid, $build_func);
}

/**
 * Get the uri to the current default image.
 *
 * The results of this function are cached.
 *
 * @return string
 *   The uri of the default image or FALSE if no default image exists.
 */
function imagecache_defaults_get_default_image_uri() {
  $cid = __FUNCTION__;
  $build_func = '_' . __FUNCTION__;
  return imagecache_defaults_cache($cid, $build_func);
}

/**
 * Cache wrapper around _imagecache_defaults_valid_image().
 *
 * The performance of is_file() is not great on NFS/CDN setups.
 *
 * @see http://drupal.org/node/908282
 */
function imagecache_defaults_valid_image($uri) {
  // Don't want to worry about it if it's not a valid image uri.
  if (!imagecache_defaults_valid_image_uri($uri)) {
    return FALSE;
  }

  $cid = __FUNCTION__ . ':' . $uri;
  $build_func = '_' . __FUNCTION__;
  $params = array(
    'uri' => $uri,
  );
  return imagecache_defaults_cache($cid, $build_func, $params);
}

/**
 * Wrapper around Image theme functions.
 */
function theme_imagecache_defaults($variables) {
  // Determine whether we're dealing with a formatter or a "raw" uri.
  $is_formatter = (!empty($variables['item']));
  // Formatters have a "uri", image styles have a "path".
  $uri = ($is_formatter) ? $variables['item']['uri'] : $variables['path'];

  $op = imagecache_defaults_get_op($uri);
  if ($op == 'remove') {
    return '';
  }
  if ($op == 'replace') {
    if ($is_formatter) {
      // If $variables['path'] links to the broken image we have to update
      // that to point to the default image too.
      $url = file_create_url($variables['item']['uri']);
      if (!empty($variables['path']['path']) && $url == $variables['path']['path']) {
        $default_uri = imagecache_defaults_get_default_image_uri();
        $variables['path']['path'] = file_create_url($default_uri);
      }
      // If $variables['image_style'] is set then theme_image_formatter calls
      // theme_image_style later so we don't have to do any work here.
      if (empty($variables['image_style'])) {
        imagecache_defaults_replace_image_variables($variables['item']);
      }
    }
    else {
      imagecache_defaults_replace_image_variables($variables);
    }
  }

  // Determine which function to use for theming.
  // First we need to know the index of the most recent call to theme() from
  // the backtrace.
  $backtrace = debug_backtrace();
  $backtrace_theme_index = NULL;
  foreach ($backtrace as $key => $trace_item) {
    if ($trace_item['function'] == 'theme') {
      $backtrace_theme_index = $key;
      break;

    }
  }

  // Next we need to lookup what theme function was overridden by ICD as the
  // theme registry was being built for this theme function.
  $function = '';
  if (!empty($backtrace_theme_index) && !empty($backtrace[$backtrace_theme_index])) {
    $theme_hook = $backtrace[$backtrace_theme_index]['args'][0];

    // We cache the original function for this $theme_hook as unserializing the
    // theme registry from the cache, while much faster than rebuilding it, is
    // still relatively slow when called many times on one page.
    $cid = __FUNCTION__ . ':' . $theme_hook;
    $build_func = '_imagecache_defaults_get_theme_function';
    $params = array(
      'theme_hook' => $theme_hook,
    );
    $function = imagecache_defaults_cache($cid, $build_func, $params);
  }
  else {
    $function = ($is_formatter) ? 'theme_image_formatter' : 'theme_image_style';
  }

  // Call the theme function, being careful to pass all expected arguments.
  $output = '';
  if (function_exists($function)) {
    $output .= $function($variables);
  }
  return $output;
}
